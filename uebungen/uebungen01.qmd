---
title: "√úbungen"
execute:
  echo: true
  output: false
format: html
filters:
  - quarto
  - line-highlight
  - fold_results
editor: visual
---

Im Folgenden wollen wir noch einmal wesentliche R-Skills ein√ºben. L√∂sungsvorschl√§ge zu den √úbungen finden Sie jeweils in eingeklappter Form:

::: {.callout-tip title="Klapp! Mich! Aus!" collapse="true"}
Am besten lassen Sie die L√∂sungen zun√§chst eingeklappt, um sich selbst auszuprobieren. Allerdings empfehle ich, dabei die richtige Balance zu finden: Ver(sch)wenden Sie nicht zu viel Zeit auf die √úbungen - wenn Sie nicht weiterwissen, schauen Sie gern die L√∂sung an. Auch im echten Leben ist es ja so, dass man beim Programmieren nicht alles auswendig wei√ü, sondern sehr viel googelt.
:::

## √úbung 1

Fangen wir mit den Basics an: Erstellen Sie mit Hilfe des Zuweisungsoperators `<-` zwei Objekte, `a` und `b`, wobei `a` den Wert 25 hat und `b` den Wert der Quadratwurzel von pi (in R als `pi` gespeichert). Anschlie√üend addieren Sie `a` und `b`.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

# Objekte erstellen
a <- 25
b <- sqrt(pi)

# addieren
a + b
```
:::

## √úbung 2a

Nun wollen wir ein√ºben, wie man Daten einliest. Wir benutzen zun√§chst den Datensatz Weg_Kx.csv, der unter data/ zur Verf√ºgung steht. Er ist so formatiert, dass Sie ihn einfach mit `read.csv` einlesen k√∂nnen. Geben Sie dem Objekt, das Sie dem Datensatz mit dem Zuweisungsoperator `<-` zuweisen, den Namen `d`.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

# Daten einlesen
d <- read.csv("data/Weg_Kx.csv")

```
:::

::: {.callout-warning title="Troubleshooting" collapse="true"}
**Ich kann den Datensatz nicht einlesen.**

Die wahrscheinlichste Option ist, dass der angegebene Dateipfad nicht stimmt. In diesem Fall erscheint eine Warnung wie die folgende:

```{r}
#| echo: true
#| output: true
#| error: true

d <- read.csv("diese_datei_existiert_nicht.csv")

```

In diesem Fall √ºberpr√ºfen Sie bitte, ob die Datei wirklich da liegt, wo Sie R gesagt haben, dass Sie liegt. Oben habe ich `data/Weg_Kx.csv` als Pfad angegeben. Der Pfad ist **relativ zum aktuellen Arbeitsverzeichnis**, das wir mit `getwd()` erfragen k√∂nnen. Mit `setwd` k√∂nnen wir au√üerdem ein neues Arbeitsverzeichnis setzen.

**Wie finde ich heraus, wo meine Datei liegt?**

Wenn Sie nicht sicher sind, wo Ihre Datei liegt, m√ºssen Sie herausfinden, wo sie sich auf Ihrer Festplatte befindet. Daf√ºr gibt es sowohl unter Windows als auch bei Mac Suchfunktionen, die die Ordner auf Ihrer Festplatte durchsuchen. Sobald Sie die Datei gefunden haben, k√∂nnen Sie mit Rechtsklick \> Pfad kopieren (Windows) bzw. Option+Command+C (Mac) den Dateipfad in die Zwischenablage kopieren und in RStudio einf√ºgen (Rechtsklick \> Einf√ºgen oder Strg+Alt+V). Achten Sie darauf, dass der Dateiname in Anf√ºhrungszeichen stehen muss; beachten Sie dabei wiederum, dass Mac automatisch Anf√ºhrungszeichen mit in die Zwischenablage kopiert, wenn irgendwo im Dateipfad z.B. ein Leerzeichen enthalten ist, und dass doppelte Anf√ºhrungszeichen nicht funktionieren. Beispiele f√ºr Code, der NICHT (!) funktioniert:

```{r}
#| eval: false

d <- read.csv(data/Weg_Kx.csv) # keine Anf√ºhrungszeichen!

d <- read.csv("'data/Weg_Kx.csv'") # mehrfache Anf√ºhrungszeichen (einmal doppelte, einmal einfache)

d <- read.csv("data/Weg_Cx.csv") # Tippfehler im Dateinamen (Cx statt Kx)

d <- read.csv("data/Weg_Kx.csv) # schlie√üendes Anf√ºhrungszeichen fehlt 
--> in diesem Fall bricht die H√∂lle los, 
weil Sie damit auch das gesamte 
weitere Skript ruinieren.....


```
:::

## √úbung 2b: Daten inspizieren

Wir wollen nun einen genaueren √úberblick √ºber die eingelesenen Daten gewinnen. Bei dem Datensatz handelt es sich um eine annotierte DWDS-Konkordanz zur deutschen *Weg*-Konstruktion (*sie bahnte sich einen Weg durch die Menge*), die [Willich (2022)](https://www.degruyter.com/document/doi/10.1515/9783110762341/html) untersucht hat.

Um einen √úberblick √ºber die Daten zu gewinnen, schauen uns zun√§chst die ersten paar Zeilen an. Nutzen Sie daf√ºr die Funktion `head`.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}
#| output: true

# erste paar Zeilen ausgeben
head(d)

```
:::

::: callout-tip
Das Paket `skimr` bietet ebenfalls praktische Funktionen, um sich einen ersten √úberblick √ºber die Struktur eines Dataframes zu verschaffen.

```{r}
#| eval: false

# Paket installieren (nur bei der ersten Benutzung des Pakets erforderlich)
install.packages("skimr")
```

```{r}
# Paket laden
library(skimr)
```

```{r, attr.output='.details summary="Output"'}
#| echo: true
#| output: true

# skim-Funktion benutzen
skim(d)
```
:::

## √úbung 2c: Variablenauspr√§gungen

Finden Sie heraus, welche unterschiedlichen Verben in der Konstruktion auftauchen. Die Verben finden Sie in der Tabellenspalte `Verb`.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

# entweder:
unique(d$Verb)

# oder
levels(factor(d$Verb))

```
:::

## √úbung 2d: Einlesen mit `readr`

Jetzt wollen wir den Datensatz noch einmal mit dem `readr`-Paket einlesen, das Teil des `tidyverse` ist. Die Funktionen darin haben fast die gleichen Namen wie die Funktionen in Base R, nur mit einem \_ statt mit einem Punkt: `read_csv` (f√ºr CSV) oder `read_delim` (f√ºr Dateien mit jeglichem Delimiter, also auch z.B. f√ºr tabseparierte Dateien oder f√ºr solche, in dem die Spalten mit einem Semikolon getrennt sind.) Laden Sie zun√§chst die `Tidyverse`-Paketfamilie und nutzen Sie dann die Funktion `read_csv`, um die CSV-Datei noch einmal einzulesen. Gern k√∂nnen Sie einfach wieder `d` als Objektname verwenden (unser altes Objekt `d` wird dann √ºberschrieben).

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

# Tidyverse laden
library(tidyverse)

# Datei einlesen
d <- read_csv("data/Weg_Kx.csv")


```
:::

Probieren Sie nun aus, was passiert, wenn Sie einfach `d` in die Kommandozeile eingeben. Sie sehen, dass der Dataframe nun eine besondere Art von Dataframe ist, ein sog. Tibble:

```{r, attr.output='.details summary="Output anzeigen"'}
#| output: true

d


```

Tibbles sind eine f√ºr das Tidyverse spezifische Datenstruktur. Mit den genauen Unterschieden zu Dataframes in Base R m√ºssen wir uns an dieser Stelle nicht besch√§ftigen, wir sollten aber im Hinterkopf behalten, dass sie teilweise andere Eigenschaften als Base-R-Dataframes haben, was zu kleineren Unterschieden dahingehend f√ºhrt, wie wir mit ihnen arbeiten k√∂nnen. Die meisten dieser Unterschiede sind aber f√ºr die basalen Operationen, um die es hier geht, irrelevant und zeigen sich eventuell bei komplexeren Operationen.

## √úbung 2e: Subsetting

Jetzt wollen wir ein subset d_bahnen erstellen, das nur diejenigen Zeilen enth√§lt, in denen das Verb *bahnen* lautet. Hier gibt es drei M√∂glichkeiten: Entweder wir nutzen die Syntax `dataframe[Zeile,Spalte]` oder wir nutzen die `subset()`-Funktion oder wir nutzen die im `tidyverse` - genauer: im Tidyverse-Paket `dplyr` - vorhandene `filter()`-Funktion. Letztere funktioniert √§hnlich wie `subset()`, hat aber noch ein paar weitere praktische Funktionen (s. die Beispiele unter `?dplyr::filter`).

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}


# Option 1: Syntax dataframe[Zeile, Spalte]:
d_bahnen <- d[which(d$Verb=="bahnen"),]

# Option 2: subset()
d_bahnen <- subset(d, Verb == "bahnen")

# Option 3: filter()
d_bahnen <- filter(d, Verb == "bahnen")


```
:::

## √úbung 3a (schwer)

Nun wollen wir einen etwas schwerer einzulesenden Datensatz einlesen, der sich nicht einfach mit `read.csv` einlesen l√§sst. Wir benutzen daf√ºr den Datensatz umfrage-praesenzlehre.csv, der ebenfalls unter data/ zur Verf√ºgung steht. Der Datensatz enth√§lt (anonyme) Resultate einer authentischen Umfrage, in der Studierende nach ihren Pr√§ferenzen bzgl. Online- vs. Pr√§senzlehre befragt wurden.

Informationen zum Datensatz:

-   tabellarische Daten, Semikolon (;) als Spaltentrenner
-   Encoding: ISO-8859-1 (Latin-1)
-   Die Spalten haben Namen, einige davon sind aber mehrfach vergeben:
    -   `Semesterzahl`
    -   `Vorlesungen`
    -   `√úbungen`
    -   `Tutorien`
    -   `Seminare`
    -   `Verf√ºgbarkeit des CIP-Pools`

Versuchen Sie zun√§chst, die Datei mit `read.csv` und/oder `read_csv` einzulesen. Was sagen uns die Fehlermeldungen?

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}
#| output: true
#| error: true

read.csv("data/umfrage-praesenzlehre.csv")

read_csv("data/umfrage-praesenzlehre.csv")


```

Zugegeben: Die Fehlermeldung ist nicht unbedingt selbsterkl√§rend. Die L√∂sung liegt in einer der oben aufgef√ºhrten Eigenschaften der Datei: R geht standardm√§√üig davon aus, dass Dateien, die eingelesen werden, die UTF-8 kodiert sind. UTF-8 ist einer von mehreren Standards zur Kodierung von Zeichen (wir d√ºrfen nicht vergessen, dass ein Computer letztlich, vereinfacht gesagt, nur mit Einsen und Nullen umgehen kann und so etwas wie Buchstaben daher irgendwie kodiert werden m√ºssen). Unsere Datei ist in Latin-1 kodiert.
:::

Wie k√∂nnen wir den Fehler beheben? Schauen Sie ggf. in die Hilfe von `?read.csv` bzw. `?read_csv` und suchen Sie in den Hilfe-Vignetten nach "encoding".

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}
#| output: false
#| error: false

read.csv("data/umfrage-praesenzlehre.csv", fileEncoding = "latin1")

read_csv("data/umfrage-praesenzlehre.csv", locale = locale(encoding = "Latin1"))


```
:::

Nun werden Sie sehen, dass die Verarbeitung immer noch nicht ganz so klappt, wie wir das wollen. Woran liegt das?

::: {.callout-tip title="L√∂sung" collapse="true"}
Es liegt nat√ºrlich daran, dass die Spalten hier nicht mit Kommata abgetrennt sind. (Wir erinnern uns: CSV steht f√ºr Comma-Separated Values.) Stattdessen sind sie, wie in der Beschreibung der Dateieigenschaften oben erw√§hnt, mit Semikola abgetrennt.
:::

Wir k√∂nnen die Funktion `read.table` (Base R) oder `read_delim` (Tidyverse) verwenden, um die Datei einzulesen. Dabei m√ºssen wir den jeweiligen Spaltentrenner (Delimiter) angeben. Achtung: Bei `read.table` hei√üt das Argument daf√ºr `sep`, bei `read_delim` hei√üt es `delim`. Denken Sie daran, auch das Encoding zu spezifizieren.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

read.table("data/umfrage-praesenzlehre.csv", sep = ";", fileEncoding = "latin1")

read_delim("data/umfrage-praesenzlehre.csv", delim=";",  locale = locale(encoding = "latin1"))


```
:::

Zur Erinnerung: Wenn wir die Dateien einfach nur mit einer der read-Funktionen einlesen, werden sie uns einfach nur in der Konsole angezeigt und verschwinden ansonsten im Limbo. Um weiter mit ihnen arbeiten zu k√∂nnen, m√ºssen wir ihnen ein Objekt zuweisen. Lesen Sie die Datei nun bitte nochmal ein und weisen sie ihr den Namen `umfrage` zu. Verwenden Sie zun√§chst die Base-R-Funktion `read.table()`.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

umfrage <- read.table("data/umfrage-praesenzlehre.csv", sep = ";", fileEncoding = "latin1")


```
:::

Schauen Sie sich die Spaltennamen an mit der Funktion `colnames()`. Was f√§llt auf? Wie k√∂nnen wir die "richtigen" Spaltennamen finden? Und wie k√∂nnen wir R dazu bringen, dass er die "richtigen" Spaltennamen auch als Spaltennamen in unserem Dataframe verwendet?

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}
#| output: true

colnames(umfrage)


```

Wir sehen, dass R die Spaltennamen nicht aus der ersten Zeile des CSV-Sheet √ºbernommen, sondern einfach durchnummeriert hat. Die Spaltennamen befinden sich nun in der ersten Zeile des Dataframe:

```{r}
#| output: true

umfrage[1,]




```

Wir k√∂nnen die Spaltennamen jedoch manuell zuweisen, indem wir sagen, dass die erste Zeile als `colnames()` verwendet werden soll. Anschlie√üend m√ºssen wir die erste Zeile aus dem Dataframe l√∂schen.

```{r}

# erste Zeile als Spaltennamen:
colnames(umfrage) <- umfrage[1,]

# erste Zeile l√∂schen:
umfrage <- umfrage[-1,]



```

Alternativ k√∂nnen wir mit der Option `header=TRUE` beim Einlesen der Datei schon sicherstellen, dass R wei√ü, dass die erste Zeile als √úberschriften, also als Spaltennamen, behandelt werden soll.

```{r}

umfrage <- read.table("data/umfrage-praesenzlehre.csv", sep = ";", fileEncoding = "latin1", header = TRUE)

```
:::

Lesen Sie nun die Dateien mit `read_delim` aus dem Tidyverse ein. Schauen Sie dann auf die Spaltennamen. Was ist anders?

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

# Daten mit read_delim einlesen:
umfrage <- read_delim("data/umfrage-praesenzlehre.csv", delim=";",  locale = locale(encoding = "latin1"))

```

```{r}
#| output: true

colnames(umfrage)

```

Wir sehen, dass die doppelten Spaltennamen automatisch desambiguiert werden, indem ihnen die Spaltennummer angeh√§ngt wird.
:::

## √úbung 3b (wieder etwas leichter)

Untersuchen Sie nun den Datensatz:

-   Welche Spalten gibt es? Welche enthalten tats√§chlich relevante Informationen?
-   Wie viele Spalten gibt es? Welche enthalten tats√§chlich relevante Informationen?
-   Warum sind einige Spaltennamen doppelt vergeben?

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}
#| output: true

# erste paar Zeilen anzeigen:
head(umfrage)

# Datenstruktur ausgeben:
str(umfrage)

# √úberblick √ºber die Daten mit skimr:
skimr::skim(umfrage)

# Spaltennamen anzeigen:
colnames(umfrage)


```

Tipp: Man kann auch mit dem `View()`-Befehl bzw. einfach mit Klick auf das jeweilige Objekt im Environment den Dataframe anzeigen.

```{r}
#| eval: false

View(umfrage)


```
:::

## √úbung 3c (wieder sehr schwer)

L√∂schen Sie nun die doppelten Spalten. Tipp: Mit `duplicated()` k√∂nnen Sie doppelte Spaltennamen finden. Das wird zun√§chst nicht gelingen, weil die Spaltennamen desambiguiert sind. Mit `gsub("\\..*", "", colnames(umfrage))` k√∂nnen Sie aber alles, was in den Spaltennamen ab dem ersten Punkt kommt, l√∂schen und damit die Original-Spaltennamen wiederherstellen, innerhalb derer Sie ebenfalls mit `duplicated` Duplikate erkennen k√∂nnen.

::: {.callout-tip title="L√∂sung" collapse="true"}
Hier zeige ich, wie sich das Ganze mit der Base-R-Variante machen l√§sst, mit den mit `read_delim` eingelesenen Daten sollte es aber genauso funktionieren.

```{r}

# Daten einlesen
umfrage <- read.table("data/umfrage-praesenzlehre.csv", sep = ";", fileEncoding = "latin1", header = TRUE)


```

Hier zeige ich zun√§chst die einzelnen Bausteine, die wir brauchen und die ich dann im n√§chsten Code zusammensetzen werde:

```{r}
#| output: true

# So zeigen wir die Spaltennamen an:
colnames(umfrage)

# Ersetzen-Befehl zum De-Desambiguieren der Spaltennamen:

gsub("\\..*", "", colnames(umfrage))

# Duplikate finden:
duplicated(gsub("\\..*", "", colnames(umfrage)))

# Position der Duplicate innerhalb der Spaltennamen finden:

which(duplicated(gsub("\\..*", "", colnames(umfrage))))

```

Diesen which-Befehl k√∂nnen wir nun benutzen, um anhand der Position der doppelten Spalten diese Spalten zu l√∂schen.

```{r}

# der Einfachheit halber speichere ich die Positionen erst in ein Objekt, um den Code lesbarer zu halten:
positionen <- which(duplicated(gsub("\\..*", "", colnames(umfrage))))

# so k√∂nnen wir die Spalten l√∂schen:
umfrage_clean <- umfrage[,-positionen]

# alternativ k√∂nnen wir auch die which-Anfrage negativ formulieren, mit dem Negationsoperator !
positionen_negiert <- which(!duplicated(gsub("\\..*", "", colnames(umfrage))))

# und dann das Subset damit erstellen, was gegen√ºber der Syntax mit "-" einigen potentiellen Problemen vorbeugt:
umfrage_clean <- umfrage[,positionen_negiert]

```
:::

Haben Sie Lust auf weitere √úbungen bekommen? [Hier](https://hartmast.github.io/WTFsem2024/uebungen/uebungen02.html) geht es weiter!

[üîô Zur√ºck zur √úbersicht](uebungen_uebersicht.html)
