---
title: "√úbungen zu regul√§ren Ausdr√ºcken"
execute:
  echo: true
  output: false
format: html
filters:
  - quarto
  - line-highlight
  - fold_results
editor: source
---

Im Folgenden wollen wir uns vertiefter mit regul√§ren Ausdr√ºcken (Regular Expressions, kurz Regex) besch√§ftigen. Eine hervorragende Ressource, um einen ersten √úberblick √ºber Regex zu bekommen, ist die Seite <https://www.regular-expressions.info/>.

## √úbung 1

Erstellen Sie ein Objekt mit dem Namen `wiesel` , das folgendes Gedicht von Christian Morgenstern in einem einzigen character string enth√§lt:

> **Das √§sthetische Wiesel**<br><br>Ein Wiesel<br>sa√ü auf einem Kiesel<br>inmitten Bachgeriesel.<br>Wi√üt ihr<br>weshalb?<br><br>Das Mondkalb<br>verriet es mir<br>im Stillen:<br><br> Das raffinier-<br>te Tier<br>tat's um des Reimes willen.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

wiesel <- "Das √§sthetische Wiesel

Ein Wiesel
sa√ü auf einem Kiesel
inmitten Bachgeriesel.
Wi√üt ihr
weshalb?

Das Mondkalb
verriet es mir
im Stillen:

Das raffinier-
te Tier
tat‚Äôs um des Reimes willen."

```
:::

Schauen Sie sich nun das erstellte Objekt an, indem Sie es in der Kommandozeile ausf√ºhren. Was sehen Sie?

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}
#| output: true

wiesel

```

Wir sehen, dass das Gedicht nun in einer Zeile ausgegeben wird. Die Zeilenumbr√ºche werden mit der sog. Escape-Sequenz \\n (f√ºr "newline") dargestellt.
:::

## √úbung 2

Nutzen Sie die Funktion `strsplit`, um das Gedicht in seine einzelnen Zeilen zu splitten. Die `strsplit`-Funktion nimmt folgende Argumente: `x` ist der character vector, den wir splittten wollen, `split` ist ein regul√§rer Ausdruck, der angibt, an welcher Stelle bzw. an welchen Stellen wir splitten wollen. Sehen Sie sich gern auch die Hilfe unter `?strsplit` an. Achten Sie auch darauf, welche Art von Output die Funktion **`strsplit`** liefert.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

strsplit(wiesel, "\n")

```
:::

## √úbung 3

Erstellen Sie einen Vektor namens `wiesel_vector`, der die via `strsplit` erstellten einzelnen Zeilen des Gedichts als Vektor enth√§lt. Achten Sie dabei darauf, dass **`strsplit`** keine Vektoren, sondern Listen ausgibt. Sie k√∂nnen die Funktion `unlist` verwenden, um eine Liste in einen Vektor zu √ºberf√ºhren.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

wiesel_vector <- unlist(strsplit(wiesel, "\n"))

```
:::

## √úbung 4

Der Vektor enth√§lt einige leere Elemente (`""`). Bitte l√∂schen Sie alle leeren Elemente aus dem Vektor.

::: {.callout-tip title="L√∂sung" collapse="true"}
Um die leeren Elemente zu l√∂schen, nehmen wir ein Subset des Vektors und behalten nur diejenigen Elemente, die nicht gleich `""` sind.

```{r}
wiesel_vector <- wiesel_vector[which(wiesel_vector!="")]
```
:::

## √úbung 5

Bitte finden Sie heraus, mit welchem regul√§ren Ausdruck man alle Satzzeichen finden kann. Anschlie√üend nutzen Sie den Befehl `gsub`, um alle Satzzeichen aus dem Vektor `wiesel_vector` zu l√∂schen.

::: {.callout-tip title="L√∂sung" collapse="true"}
Satzzeichen finden wir mit dem regul√§ren Ausdruck `[[:punct:]]`.

```{r}

wiesel_vector <- gsub("[[:punct:]]", "", wiesel_vector)

```
:::

## √úbung 6 (etwas schwerer)

Nun wollen wir daf√ºr sorgen, dass das jeweils erste Wort jedes Vektors mit einem Kleinbuchstaben beginnt. Tipp: Mit der Funktion `tolower` konvertieren Sie einen character string mit Gro√übuchstaben in einen, der nur Kleinbuchstaben enth√§lt. Noch ein Tipp: Wir haben oben gesehen, dass wir mit `unlist(strsplit(...))` die character strings aufsplitten k√∂nnen. Mit `paste0` k√∂nnen wir sie auch wieder zusammensetzen. Konsultieren Sie ggf. die Hilfefunktion der genannten Funktionen.

::: {.callout-tip title="L√∂sung" collapse="true"}
Wir k√∂nnen einen Loop schreiben, der die einzelnen Zeilen mit `strsplit` aufsplittet, das erste Wort mit `tolower` ersetzt und das Ganze dann mit `paste0` wieder zusammenf√ºgt.

Schauen wir uns zun√§chst an, wie das f√ºr einen einzigen String, n√§mlich den ersten, funktioniert:

```{r}

# der aktuelle Vektor:
cur_vec <- unlist(strsplit(wiesel_vector[1], " "))

# im aktuellen Vektor das erste Wort klein machen:
cur_vec[1] <- tolower(cur_vec[1])

# den Vektor wieder zusammenpasten; mit collapse = " " stellen wir sicher, dass ein Leerzeichen zwischen die W√∂rter kommt und kein anderes Zeichen:
cur_vec <- paste0(cur_vec, collapse = " ")

```

```{r}
#| output: true

# √ºberpr√ºfen, dass alles geklappt hat
cur_vec

```

Das Ganze k√∂nnen wir nun in einen Loop √ºberf√ºhren. Hier k√∂nnen wir fast alles von oben copy&pasten, m√ºssen die `[1]`, die sich auf die Position im `wiesel_vector` bezieht, durch unseren Iterator - hier `i` - ersetzen und m√ºssen dann nur noch daran denken, den jeweiligen String im Gesamtvektor durch unseren aktuellen Vektor zu ersetzen.

```{r}

for(i in 1:length(wiesel_vector)) {
  # der aktuelle Vektor:
cur_vec <- unlist(strsplit(wiesel_vector[i], " "))

# im aktuellen Vektor das erste Wort klein machen:
cur_vec[1] <- tolower(cur_vec[1])

# den Vektor wieder zusammenpasten
cur_vec <- paste0(cur_vec, collapse = " ")

# den String im Gesamtvektor durch den aktuellen String ersetzen:
wiesel_vector[i] <- cur_vec

}

```

Nun k√∂nnen wir schauen, ob alles geklappt hat:

```{r}
#| output: true

wiesel_vector
```
:::

## √úbung 7

Wir wollen nun den Text in einen Dataframe √ºberf√ºhren, dem wir dann weitere Spalten mit (automatischer) Annotation hinzuf√ºgen k√∂nnen. Erstellen Sie bitte einen Dataframe (mit `data.frame`) namens `wiesel_df`, der nur eine Spalte mit dem Namen "Text" enth√§lt, in der sich unser `wiesel_vector` befindet.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

wiesel_df <- data.frame(Text = wiesel_vector)

```
:::

## √úbung 8 (etwas schwerer)

Nun wollen wir eine Annotationsspalte hinzuf√ºgen, in der wir automatisch angeben, ob der Text in der jeweiligen Tabellenzeile ein Substantiv enth√§lt (Namensvorschlag f√ºr die zu erstellende neue Spalte: `mit_Substantiv`). Finden Sie daf√ºr heraus, wie man Gro√übuchstaben mit regul√§ren Ausdr√ºcken erkennt, und nutzen Sie die Suchfunktion `grep`, um nach gro√ügeschriebenen W√∂rtern in den Tabellen- und damit Gedichtzeilen zu suchen. Tipp: Mit der Funktion `grepl` k√∂nnen Sie sich statt der Position der Suchtreffer f√ºr jedes Element in einem Vektor (oder einer Dataframe-Spalte) ausgegeben lassen, ob das gesuchte Element dort gefunden wurde oder nicht.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}

# so finden wir heraus, ob ein Gro√übuchstabe gefunden wurde:
grepl("[A-Z]", wiesel_df$Text)

# so f√ºgen wir das Ganze als neue Spalte zum existierenden Dataframe hinzu:
wiesel_df$mit_Substantiv <- grepl("[A-Z]", wiesel_df$Text)

```
:::

## √úbung 9

Jetzt wollen wir alle Substantive aus unserem Vektor extrahieren. Tipp: Hierf√ºr bietet es sich an, den Text zun√§chst in Einzelw√∂rter aufzuspalten.

::: {.callout-tip title="L√∂sung" collapse="true"}
```{r}
# Text in Einzelw√∂rter aufspalten
wiesel_woerter <- unlist(strsplit(wiesel_df$Text, " "))

# W√∂rter finden, die mit einem Gro√übuchstaben beginnen:
# ^ gibt an, dass der gesuchte String am Anfang stehen muss. (Hier prinzipiell nicht notwenig, da im Deutschen Gro√übuchstaben in aller Regel nur am Wortanfang stehen k√∂nnen, mit wenigen Ausnahmen). Mit value = T geben wir an, dass wir statt der Positionen im Vektor die tats√§chlichen Werte ausgegeben bekommen wollen.
grep("^[A-Z]", wiesel_woerter, value = T)

```
:::

[üîô Zur√ºck zur √úbersicht](uebungen_uebersicht.html)
